# -*- coding: utf-8 -*-
"""app_final1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PE13MuB2beHJmzcMnwzqJ9UqUBteqFKA
"""

import os
import streamlit as st
import pandas as pd
import numpy as np
import joblib
from sklearn.preprocessing import LabelEncoder, OrdinalEncoder, StandardScaler

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# --- Load Models and Assets ---
delay_days_model = joblib.load(os.path.join(BASE_DIR, 'best_model_rf.pkl'))
classification_model = joblib.load(os.path.join(BASE_DIR, 'random_forest_model_classification.pkl'))
financial_model = joblib.load(os.path.join(BASE_DIR, 'random_forest_top5_cost_model.pkl'))

delay_days_features = joblib.load(os.path.join(BASE_DIR, 'Delay_Days_Features_list.pkl'))
classification_features = joblib.load(os.path.join(BASE_DIR, 'top_features_classification.pkl'))
financial_features = joblib.load(os.path.join(BASE_DIR, 'random_forest_top5_cost_features.pkl'))

financial_scaler = joblib.load(os.path.join(BASE_DIR, 'financial_scaler.pkl'))

# --- Label Encoders Setup for Classification ---
label_encoders = {}
label_cols = {
    'Weather_Condition_On_Delivery': ['STORM', 'CLEAR', 'SNOW', 'RAIN'],
    'Brake_System_Supplier_Group': ['SOUTH_SEA', 'EAST_SEA', 'EAST_AIR', 'NORTH_SEA', 'NORTH_AIR',
                                    'NORTH_ROAD', 'WEST_SEA', 'WEST_ROAD', 'WEST_AIR', 'SOUTH_ROAD',
                                    'EAST_ROAD', 'SOUTH_AIR'],
    'Transmission_Supplier_Group': ['NORTH_ROAD', 'EAST_AIR', 'EAST_ROAD', 'SOUTH_SEA', 'WEST_ROAD',
                                    'NORTH_AIR', 'WEST_SEA', 'EAST_SEA', 'SOUTH_ROAD', 'NORTH_SEA',
                                    'WEST_AIR', 'SOUTH_AIR'],
    'Infotainment_Supplier_Group': ['NORTH_ROAD', 'WEST_SEA', 'EAST_AIR', 'EAST_SEA', 'WEST_ROAD',
                                    'SOUTH_AIR', 'EAST_ROAD', 'SOUTH_ROAD', 'NORTH_AIR', 'WEST_AIR',
                                    'SOUTH_SEA', 'NORTH_SEA']
}
for col, categories in label_cols.items():
    le = LabelEncoder()
    le.fit(categories)
    label_encoders[col] = le

# --- Ordinal Encoder Setup ---
TRAFFIC_LEVEL_CATEGORIES = [['LOW', 'MODERATE', 'HIGH']]
ordinal_encoder = OrdinalEncoder(categories=TRAFFIC_LEVEL_CATEGORIES)
ordinal_encoder.fit([[cat] for cat in TRAFFIC_LEVEL_CATEGORIES[0]])

# --- Utility Functions ---
def safe_float(val, name):
    try:
        return float(val), None
    except:
        return None, f"Invalid input for {name}. Please enter a valid number."

def check_features_match(df, expected_features):
    df_cols = list(df.columns)
    if df_cols != expected_features:
        missing = set(expected_features) - set(df_cols)
        extra = set(df_cols) - set(expected_features)
        return False, missing, extra
    return True, None, None

# --- Input Collectors ---
def get_numeric_inputs(feature_list, prefix=""):
    inputs, errors = {}, []
    for feature in feature_list:
        val = st.text_input(f"{feature}", key=f"{prefix}_{feature}")
        fval, err = safe_float(val, feature)
        if err:
            errors.append(err)
        else:
            inputs[feature] = fval
    return inputs, errors

def get_classification_inputs(prefix=""):
    inputs, errors = {}, []
    for feature in classification_features:
        if feature in label_encoders:
            val = st.selectbox(f"{feature}", label_encoders[feature].classes_, key=f"{prefix}_{feature}")
            inputs[feature] = val
        elif feature == 'Traffic_Level':
            val = st.selectbox("Traffic_Level", ['LOW', 'MODERATE', 'HIGH'], key=f"{prefix}_Traffic_Level")
            inputs['Traffic_Level'] = val
        elif feature in ['Any_Critical_Part_Delayed', 'Engine_Delayed_Flag']:
            val = st.selectbox(f"{feature}", [0, 1], key=f"{prefix}_{feature}")
            inputs[feature] = val
        else:
            val = st.text_input(f"{feature}", key=f"{prefix}_{feature}")
            fval, err = safe_float(val, feature)
            if err:
                errors.append(err)
            else:
                inputs[feature] = fval
    return inputs, errors

# --- Main App ---
def main():
    st.title("Car Shipment Delay Prediction App")
    tab1, tab2, tab3 = st.tabs(["ðŸ“¦ Delay Days", "ðŸš¦ Delay Classification", "ðŸ’° Financial Impact"])

    # --- Delay Days Regression ---
    with tab1:
        inputs, errors = get_numeric_inputs(delay_days_features, prefix="delay_days")
        if st.button("Predict Delay Days"):
            if errors:
                for e in errors:
                    st.error(e)
            else:
                try:
                    df = pd.DataFrame([inputs])
                    ok, missing, extra = check_features_match(df, delay_days_features)
                    if not ok:
                        st.error(f"Feature mismatch! Missing: {missing}, Extra: {extra}")
                    else:
                        pred = delay_days_model.predict(df[delay_days_features])[0]
                        st.success(f"ðŸšš Estimated Delay: {pred:.2f} days")
                except Exception as e:
                    st.error(f"Prediction failed: {e}")

    # --- Classification ---
    with tab2:
        inputs, errors = get_classification_inputs(prefix="classification")
        if st.button("Predict Shipment Delay"):
            if errors:
                for e in errors:
                    st.error(e)
            else:
                try:
                    df = pd.DataFrame([inputs])

                    # Label encode categorical columns
                    for col in label_encoders:
                        df[col] = label_encoders[col].transform(df[col])

                    # Ordinal encode Traffic_Level
                    df['Traffic_Level'] = ordinal_encoder.transform(df[['Traffic_Level']])

                    # Reorder columns to match model training
                    df = df[classification_features]

                    ok, missing, extra = check_features_match(df, classification_features)
                    if not ok:
                        st.error(f"Feature mismatch! Missing: {missing}, Extra: {extra}")
                        return

                    pred = classification_model.predict(df)[0]
                    proba = classification_model.predict_proba(df)[0][1]
                    st.success(f"ðŸš¨ Delay Prediction: {pred} (Probability: {proba:.2%})")
                except Exception as e:
                    st.error(f"Prediction error: {e}")

    # --- Financial Impact ---
    with tab3:
        inputs, errors = get_numeric_inputs(financial_features, prefix="financial")
        if st.button("Predict Financial Impact"):
            if errors:
                for e in errors:
                    st.error(e)
            else:
                try:
                    df = pd.DataFrame([inputs])

                    ok, missing, extra = check_features_match(df, financial_features)
                    if not ok:
                        st.error(f"Feature mismatch! Missing: {missing}, Extra: {extra}")
                        return

                    # Apply saved scaler before prediction
                    X_scaled = financial_scaler.transform(df[financial_features])

                    pred_log = financial_model.predict(X_scaled)[0]
                    pred_usd = np.expm1(pred_log)
                    st.success(f"ðŸ’¸ Predicted Financial Impact: ${pred_usd:,.2f} USD")
                except Exception as e:
                    st.error(f"Prediction error: {e}")

if __name__ == '__main__':
    main()